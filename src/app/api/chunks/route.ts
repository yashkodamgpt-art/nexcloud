import { prisma } from "@/lib/prisma";
import { NextRequest, NextResponse } from "next/server";

// CORS headers for HarborFlow GUI
const corsHeaders = {
    "Access-Control-Allow-Origin": "*",
    "Access-Control-Allow-Methods": "GET, POST, PATCH, DELETE, OPTIONS",
    "Access-Control-Allow-Headers": "Content-Type, x-api-key",
};

// OPTIONS handler for CORS preflight
export async function OPTIONS() {
    return new NextResponse(null, { status: 204, headers: corsHeaders });
}

// POST /api/chunks - Create/register a chunk or pod
export async function POST(request: NextRequest) {
    try {
        const body = await request.json();
        const apiKey = request.headers.get("x-api-key") || body.apiKey;
        const { name, diracs, dc, dm, ds, db, type, storage, ram, cpu } = body;

        if (!apiKey || !name) {
            return NextResponse.json(
                { error: "apiKey and name are required" },
                { status: 400, headers: corsHeaders }
            );
        }

        // Find user by API key
        const user = await prisma.user.findUnique({
            where: { apiKey },
        });

        if (!user) {
            return NextResponse.json(
                { error: "Invalid API key" },
                { status: 401, headers: corsHeaders }
            );
        }

        // Calculate Diracs if not provided
        const finalDiracs = diracs || 5;
        const finalDc = dc || finalDiracs * 10;
        const finalDm = dm || finalDiracs * 16;
        const finalDs = ds || finalDiracs * 50;
        const finalDb = db || finalDiracs * 10;

        // Create new chunk (unique ID generated by Prisma)
        const chunk = await prisma.chunk.create({
            data: {
                name,
                userId: user.id,
                status: "online",
                type: type || "chunk",
                diracs: finalDiracs,
                dc: finalDc,
                dm: finalDm,
                ds: finalDs,
                db: finalDb,
                storage: storage || 0,
                ram: ram || 0,
                cpu: cpu || 0,
                lastSeen: new Date(),
            },
        });

        return NextResponse.json({
            success: true,
            chunk: {
                id: chunk.id,
                name: chunk.name,
                status: chunk.status,
                type: chunk.type,
                diracs: chunk.diracs,
                dc: chunk.dc,
                dm: chunk.dm,
                ds: chunk.ds,
                db: chunk.db,
            },
        }, { headers: corsHeaders });
    } catch (error) {
        console.error("Chunk registration error:", error);
        return NextResponse.json(
            { error: "Failed to register chunk" },
            { status: 500, headers: corsHeaders }
        );
    }
}

// GET /api/chunks - List user's chunks (requires API key in header)
export async function GET(request: NextRequest) {
    try {
        const apiKey = request.headers.get("x-api-key");

        if (!apiKey) {
            return NextResponse.json(
                { error: "API key required in x-api-key header" },
                { status: 401, headers: corsHeaders }
            );
        }

        const user = await prisma.user.findUnique({
            where: { apiKey },
            include: {
                chunks: {
                    orderBy: { createdAt: "desc" },
                    include: {
                        projects: {
                            select: {
                                id: true,
                                name: true,
                                subdomain: true,
                                tunnelUrl: true,
                                status: true,
                                githubRepoUrl: true,
                                githubBranch: true,
                            }
                        }
                    }
                }
            },
        });

        if (!user) {
            return NextResponse.json(
                { error: "Invalid API key" },
                { status: 401 }
            );
        }

        return NextResponse.json({
            chunks: user.chunks.map(chunk => {
                // Find any project (running, pending, or stopped)
                const project = chunk.projects[0];

                return {
                    id: chunk.id,
                    name: chunk.name,
                    status: chunk.status,
                    type: chunk.type,
                    diracs: chunk.diracs,
                    dc: chunk.dc,
                    dm: chunk.dm,
                    ds: chunk.ds,
                    db: chunk.db,
                    usageDc: chunk.usageDc,
                    usageDm: chunk.usageDm,
                    usageDs: chunk.usageDs,
                    usageDb: chunk.usageDb,
                    lastSeen: chunk.lastSeen,
                    // Include project deployment info
                    inUse: project?.status === 'running',
                    deployment: project ? {
                        projectId: project.id,
                        name: project.name,
                        subdomain: project.subdomain,
                        url: project.tunnelUrl || `https://${project.subdomain}.harbornex.dev`,
                        status: project.status,
                        repoUrl: project.githubRepoUrl,
                        branch: project.githubBranch || 'main',
                    } : null
                };
            })
        }, { headers: corsHeaders });
    } catch (error) {
        console.error("Chunk list error:", error);
        return NextResponse.json(
            { error: "Failed to list chunks" },
            { status: 500, headers: corsHeaders }
        );
    }
}

// PATCH /api/chunks?id=xxx - Update chunk (heartbeat, status update)
export async function PATCH(request: NextRequest) {
    try {
        const apiKey = request.headers.get("x-api-key");
        const chunkId = request.nextUrl.searchParams.get("id");
        const body = await request.json();

        if (!apiKey) {
            return NextResponse.json(
                { error: "API key required in x-api-key header" },
                { status: 401, headers: corsHeaders }
            );
        }

        if (!chunkId) {
            return NextResponse.json(
                { error: "Chunk ID required" },
                { status: 400, headers: corsHeaders }
            );
        }

        // Find user by API key
        const user = await prisma.user.findUnique({
            where: { apiKey },
        });

        if (!user) {
            return NextResponse.json(
                { error: "Invalid API key" },
                { status: 401, headers: corsHeaders }
            );
        }

        // Find chunk and verify ownership
        const chunk = await prisma.chunk.findUnique({
            where: { id: chunkId },
        });

        if (!chunk || chunk.userId !== user.id) {
            return NextResponse.json(
                { error: "Chunk not found" },
                { status: 404, headers: corsHeaders }
            );
        }

        // Update chunk with new data
        const updatedChunk = await prisma.chunk.update({
            where: { id: chunkId },
            data: {
                status: body.status || "online",
                lastSeen: new Date(),
            },
        });

        return NextResponse.json({
            success: true,
            chunk: {
                id: updatedChunk.id,
                name: updatedChunk.name,
                status: updatedChunk.status,
                lastSeen: updatedChunk.lastSeen,
            },
        }, { headers: corsHeaders });

    } catch (error) {
        console.error("Chunk update error:", error);
        return NextResponse.json(
            { error: "Failed to update chunk" },
            { status: 500, headers: corsHeaders }
        );
    }
}

// DELETE /api/chunks?id=xxx - Delete a chunk (and clean up)
export async function DELETE(request: NextRequest) {
    try {
        const apiKey = request.headers.get("x-api-key");
        const chunkId = request.nextUrl.searchParams.get("id");

        if (!apiKey) {
            return NextResponse.json(
                { error: "API key required" },
                { status: 401, headers: corsHeaders }
            );
        }

        if (!chunkId) {
            return NextResponse.json(
                { error: "Chunk ID required" },
                { status: 400, headers: corsHeaders }
            );
        }

        const user = await prisma.user.findUnique({
            where: { apiKey },
        });

        if (!user) {
            return NextResponse.json(
                { error: "Invalid API key" },
                { status: 401, headers: corsHeaders }
            );
        }

        // Verify chunk belongs to user
        const chunk = await prisma.chunk.findUnique({
            where: { id: chunkId },
            include: { projects: true }
        });

        if (!chunk || chunk.userId !== user.id) {
            return NextResponse.json(
                { error: "Chunk not found" },
                { status: 404, headers: corsHeaders }
            );
        }

        // Disconnect projects from this chunk (don't delete them)
        await prisma.project.updateMany({
            where: { chunkId: chunkId },
            data: { chunkId: null }
        });

        // Delete the chunk
        await prisma.chunk.delete({
            where: { id: chunkId }
        });

        return NextResponse.json({
            success: true,
            message: `Chunk "${chunk.name}" deleted. ${chunk.projects.length} projects unlinked.`
        }, { headers: corsHeaders });

    } catch (error) {
        console.error("Chunk delete error:", error);
        return NextResponse.json(
            { error: "Failed to delete chunk" },
            { status: 500, headers: corsHeaders }
        );
    }
}
